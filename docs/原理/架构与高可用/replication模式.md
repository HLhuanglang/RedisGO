# 高可用-主从复制

## 概述

主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

主从复制的意义：
- 故障恢复：主节点出现问题时候，从节点能够提供服务，实现快速的故障恢复。
- 负载均衡：主提供读写，从提供读
- 高可用的基础：

主从复制有如下特点：
- 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库；
- 从数据库一般是只读的，并且接收主数据库同步过来的数据；
- 一个master可以拥有多个slave，但是一个slave只能对应一个master；
- slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来；
- master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务；
- master挂了以后，不会在slave节点中重新选一个master；

Redis原生复制弊端简要如下：
- Redis复制中断后，从节点会立即发起psync，psync尝试部分同步，如果不成功，就会全量同步RDB并发送至从节点。
- 如果Redis全量同步，会导致主节点执行全量备份，进程 Fork，可造成主节点达到毫秒或秒级的卡顿。
- Redis进程Fork导致Copy-On-Write，Copy-On-Write导致主节点进程内存消耗，极端情况下造成主节点内存溢出，程序异常退出。
- Redis主节点生成备份文件导致服务器磁盘IO和CPU资源消耗。
- 发送GB级别大小的备份文件，会导致服务器网络出口爆增，磁盘顺序IO吞吐量高，期间会影响业务正常请求响应时间，并产生其他连锁影响。

## 如何保证数据一致性

采用读写分离的模式，主节点提供读写能力，从节点只读。

## 原理

复制方式：(ps：2.8版本之前只有全量复制，2.8之后新增了增量复制)
- 全量复制
- 增量复制

### 全量复制

![](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20241018105752.png)

第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。

第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。

第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。


### 增量复制

![](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20241018110626.png)

如果你有多个从库，则在每次连接的时候需要注意一些细节，如下:

- 多个从库情况下，每个从库都会记录自己的 slave_repl_offset，各自复制的进度也不相同。
- 重连主库进行恢复时，从库会通过 psync 命令将 slave_repl_offset 告知主库，主库判断从库的状态，来决定进行增量复制，还是全量复制。
- replication buffer 和 repl_backlog 的说明
  - repl_backlog_buffe：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。
  - replication buffer：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。
- 主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，需要将自己的复制进度（slave_repl_offset）发给主库，主库才可以按照偏移量取数据跟它同步。

## 基于状态机实现

主从复制可以划分成四个阶段：
- 初始化阶段
- 建立链接阶段
- 主从握手阶段
- 复制类型判断与执行阶段

![](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20241018111229.png)

## FAQ

Q：如果主节点挂了,从节点如何提供服务?
A：按照原始的搭建方法，主节点挂了之后只能提供读能力了，但是可以用一些HA组件来实现自动的故障切换(例如keepalived之类)



## 参考
- [主从复制原理](https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html)
- [Redis高可用-主从架构](https://www.cnblogs.com/wzh2010/p/18030905)
- [主从复制-基于状态机的设计与实现](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/21%20%20%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%ef%bc%9a%e5%9f%ba%e4%ba%8e%e7%8a%b6%e6%80%81%e6%9c%ba%e7%9a%84%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0.md)